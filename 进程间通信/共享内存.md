使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针其他通信机制运行效率较低设计的。往往与其它通信机制，如信号量结合使用， 来达到进程间的同步及互斥。

* 写共享内存  
```c
#include <stdio.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>

typedef struct share_data
{
	int count;
	int size;
	char str[128];
}SHARE_DATA;

char* path = "./shared_data";

int main()
{
	SHARE_DATA *p_data;
	int shmid;
	FILE* fd;

	p_data = (SHARE_DATA*)calloc(1, sizeof(SHARE_DATA));
	if(!p_data)
	{
		printf("malloc failed.\n");
		return -1;
	}
	p_data->count = 123;
	p_data->size = 1000;
	memset(&p_data->str, 0, 128);
	strncpy(p_data->str, "data1", 5);
	
	// 创建共享内存
	shmid = shmget(ftok(path,'a'), sizeof(SHARE_DATA), IPC_CREAT|IPC_EXCL);

	if (-1 == shmid)
	{	
		printf("shmget failed.\n");
		return -1;
	}

	printf("create shard memeory success\n");	
	
	fd = fopen(path, "w+");
	if (NULL == fd)
		printf("open file %s failed. %s\n", path, strerror(errno));
	
	// 把shmid写入文件
	fwrite(&shmid, 1, sizeof(int), fd);

	// 映射
	p_data = shmat(shmid,NULL,0);

	// 解除映射
	shmdt(p_data);

	return 0;
} 

```
