# 字节序
  计算机数据存储有两种字节优先顺序：**高位字节优先（称为大端模式）和低位字节优先（称为小端模式）**。内存的低地址存储数据的低字节，高地址存储数据的高字节的方式叫小端模式。内存的高地址存储数据的低字节，低地址存储数据高字节的方式称为大端模式。  
  **网络字节序都是大端模式。**  
  要把主机字节序和网络字节序相互对应起来，需要对这两个字节存储优先顺序进行相互转化。这里用到四个函数：htons(),ntohs(),htonl()和ntohl().这四个地址分别实现网络字节序和主机字节序的转化，这里的h代表host,n代表network，s代表short，l代表long。通常16位的IP端口号用s代表，而IP地址用l来代表。

# IP地址格式化
  通常用户在表达地址时采用的是点分十进制表示的数值（或者是为冒号分开的十进制Ipv6地址），而在通常使用的socket编程中使用的则是32位的网络字节序的二进制值，这就需要将这两个数值进行转换。这里在Ipv4中用到的函数有inet_aton()、inet_addr()和inet_ntoa()，而IPV4和Ipv6兼容的函数有inet_pton()和inet_ntop()。
  
# 主机名与IP地址转化
  gethostbyname()是将主机名转化为IP地址，gethostbyaddr()则是逆操作，是将IP地址转化为主机名。

# TCP连接
* 为什么TCP建立连接是三次握手，而断开连接是四次？  

* TCP建立连接和断开连接的各过程中的状态是如何转换的  
  客户端：主动打开SYN_SENT--->ESTABLISHED--->主动关闭FIN_WAIT_1--->FIN_WAIT_2--->TIME_WAIT  
  服务器端：LISTEN（被动打开）--->SYN_RCVD--->ESTABLISHED--->CLOSE_WAIT(被动关闭)--->LAST_ACK--->CLOSED
  
# 粘包
* 什么是粘包？   
  粘包在流传输中出现，UDP不会出现粘包，因为它有消息边界。
* socket中造成粘包的原因
  + 1 发送端需要等缓冲区满才发送出去，造成粘包
  + 2 接收方不及时接收缓冲区的包，造成多个包接收
* 哪些情况会发生粘包
  + 如果利用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题
  + 如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包
  + 如果双方建立连接，需要在连接后一段时间内发送不同结构数据，则需要考虑粘包  
* 如何解决粘包：
  + 对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满
  + 对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；
  + 由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。

# IO多路复用
* 为什么引入epool与select、区别有哪些  
  当需要读两个以上的I/O的时候，如果使用阻塞式的I/O，那么可能长时间的阻塞在一个描述符上面，另外的描述符虽然有数据但是不能读出来，这样实时性不能满足要求
* epool与select的区别有哪些 

# 实战
* 写一个server程序需要注意哪些问题  


