# TCP连接
* 为什么TCP建立连接是三次握手，而断开连接是四次？  

* TCP建立连接和断开连接的各过程中的状态是如何转换的  
  客户端：主动打开SYN_SENT--->ESTABLISHED--->主动关闭FIN_WAIT_1--->FIN_WAIT_2--->TIME_WAIT  
  服务器端：LISTEN（被动打开）--->SYN_RCVD--->ESTABLISHED--->CLOSE_WAIT(被动关闭)--->LAST_ACK--->CLOSED
  
# 粘包
* 什么是粘包？   
  粘包在流传输中出现，UDP不会出现粘包，因为它有消息边界。
* socket中造成粘包的原因
  + 1 发送端需要等缓冲区满才发送出去，造成粘包
  + 2 接收方不及时接收缓冲区的包，造成多个包接收
* 哪些情况会发生粘包
  + 如果利用tcp每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题
  + 如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就ok，也不用考虑粘包
  + 如果双方建立连接，需要在连接后一段时间内发送不同结构数据，则需要考虑粘包  
* 如何解决粘包：
  + 对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满
  + 对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；
  + 由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。

# IO多路复用
* 为什么引入epool与select、区别有哪些  
  当需要读两个以上的I/O的时候，如果使用阻塞式的I/O，那么可能长时间的阻塞在一个描述符上面，另外的描述符虽然有数据但是不能读出来，这样实时性不能满足要求
* epool与select的区别有哪些 

# 实战
* 写一个server程序需要注意哪些问题  


